n = int(input())

# 0부터 1이 모두 등장하는 계단 수
# dp[i][j][k] = i자리 수에 j숫자에 이진수 k개의 숫자가 반영되어 있을 때
# ex) dp[1][1] += dp[1-1][1-1]
# 2차원 dp에선 i자리 수에 j가 들어가는 것까지만 알지 그 전에(i-1)에는 뭐가 들어갔는지 모른다.
# 따라서 3차원 배열로 0~9까지의 숫자가 들어갔는지 아닌지를 체크해줘야 함. => 비트마스킹
# 비트마스킹 -> 0-9까지의 숫자가 등장했는지 아닌지를 2진수로 체크함.
# ex) 2가 등장함 0000000100 = > 4, 5가 등장함 0000100000 => 32
# 점화식에서 이전 단계에서 현재 숫자를 붙일 때 비트를 갱신해주기
# '<<' 시프트 연산자, 1 << n = 1을 n칸 왼쪽으로 이동
# '|' OR 연산자, A,B 중 하나라도 켜져 있다면 켜라.(기존 상태에 새로운 방문 기록 추가)
# 0-9번 전구가 전부 켜있는지를 확인해야 함 = ('1' 9개 = 2^10 - 1) = 1023
dp = [[[0] * 1024 for _ in range(10)] for _ in range(n+1)]
# 1자리 수에 i라는 숫자가 들어가는 경우(1을 i칸 이동)
for i in range(1,10):
    dp[1][i][1 << i] = 1

# 현재 숫자 길이
for i in range(1,n):
    # 현재 끝자리 숫자
    for j in range(10):
        # 지금까지 방문한 숫자들의 스위치 상태
        for k in range(1024):
            # 존재할 수 없는 숫자면 pass
            if dp[i][j][k] == 0: continue

            # -1
            if j - 1 >= 0:
                nxt = k | (1 << (j-1))
                dp[i+1][j-1][nxt] += dp[i][j][k]
            # +1
            if j + 1 <= 9:
                nxt = k | (1 << (j+1))
                dp[i+1][j+1][nxt] += dp[i][j][k]

ans = 0
for i in range(10):
    ans += dp[n][i][1023]
print(ans % 1000000000)